<!DOCTYPE html>
<html>

<body>

  <h1 align="center">Web Crypto API TestWebsite für Regel 2</h1>
  <br>
  <br>
  <br>
  <p>Der erste Test soll aufzeigen, dass bei Zuweisen des API Calls zu einer Variable, erkannt wird welche Variable den API Call hält. Außerdem wird gezeigt, dass wenn der API Call verschachtelt in einer Variable enthalten ist, dies auch erkannt wird. Bspw. wenn ein Objekt der Variable "T1" zugewiesen wird und der API Call im Objekt unter dem Key "O1" enthalten ist. Ebenfalls wird gezeigt, das dies auch korrekt aufgelöst wird, wenn auf die Variable zugegriffen wird. 
    <br>
    <br>
    1. die erste Cipher kommt aus der Funktion "t1()" und mündet in der Sign Funktion. 
    <br>
    Ergebniss sollte <span style="color: green; font-weight: bold;">true</span> sein.
    <br>
    2. die zweite Cipher kommt aus der Variable "t2" und mündet in der Sign Funktion. 
    <br>
    Ergebniss sollte <span style="color: green; font-weight: bold;">true</span> sein.
    <br>
    3. die dritte Cipher kommt aus der Variable "t3" und wird nicht aufgerufen. 
    <br>
    Ergebniss sollte <span style="color: red; font-weight: bold;">false</span> sein.
    <br>
    4. die vierte Cipher kommt aus einem Objekt mit dem Key "t4" das in der Variable "t4" enthalten ist und mündet in der Sign Funktion. 
    <br>
    Ergebniss sollte <span style="color: green; font-weight: bold;">true</span> sein.
    <br>
    5. die fünfte Cipher kommt aus einem Objekt mit dem Key "t4" das in der Variable "t4" enthalten ist und mündet in keiner Sign Funktion. 
    <br>
    Ergebniss sollte <span style="color: red; font-weight: bold;">false</span> sein.
    <br>
    6. die sechste Cipher kommt aus dem Array "t5" am Index 4 und mündet in der Sign Funktion. 
    <br>
    Ergebniss sollte <span style="color: green; font-weight: bold;">true</span> sein.
    <br>
    7. die siebte Cipher kommt aus dem Array "t5a" am Index 4 und mündet in keiner Sign Funktion. 
    <br>
    Ergebniss sollte <span style="color: red; font-weight: bold;">false</span> sein.
    <br>
    8. die achte Cipher kommt aus einem Objekt mit dem Key "t6", welches in einem Array ist am Index 3 und ist in der Variable "t6" entahlten und mündet in der Sign Funktion. 
    <br>
    Ergebniss sollte <span style="color: green; font-weight: bold;">true</span> sein.
    <br>
    9. die neunte Cipher kommt aus einem Objekt mit dem Key "t6", welches in einem Array ist am Index 3 und ist in der Variable "t6" entahlten  und mündet in keiner Sign Funktion. 
    <br>
    Ergebniss sollte <span style="color: red; font-weight: bold;">false</span> sein.
  </p>
  <button id="test1">Test 1</button>
  <br>
  <br>
  <br>
  <p>
    Der zweite Test soll aufzeigen das bei einer Funktion die den API Call wiedergibt, auch nachverfolgt werden kann, dass zumindes ein Funktionscall in einem API Call der Sign Methode mündet. Hier soll auch aufgezeigt werden, dass wenn die Funktion bspw. ein Array wiedergibt, in dem der Ciphertext enthalten ist, dass auch erkannt wird ob der Ciphertext an der korrekten Stelle des Arrays abgerufen wird und in der Sign Methode mündet. In diesen Test gibt 3 Encrypt API Calls, die aus der Funktion "t2()" in einem Array wiedergegeben werden durch "return".
    <br>
    <br>
     1. Die erste Cipher ist selber in einer Funktion "t1()", die die Cipher wiedergibt. Diese wird einmal korrekt aufgerufen und Signiert. 
     <br>
     Das Ergebnis sollte <span style="color: green; font-weight: bold;">true</span> sein.
    <br>
    2. Die zweite Cipher ist in der Variable "t2" enthalten, als ein Objekt mit dem Key "t4". Diese wird 2 mal aufgerufen, wobei sie einmal in einer Sign Funktion mündet und einmal nicht. 
    <br>
    Das Ergebnis sollte <span style="color: green; font-weight: bold;">true</span> sein. 
    <br>
    3. Die dritte Cipher ist in der Variable "t3" enthalten, als ein Objekt mit dem Key "t6", welches in einem Array ist an dem Index 3. Diese wird 4 mal aufgerufen, sie 3 mal in einer Sign Funktion mündet und einmal nicht. Hier wird auch 2 mal die Cipher an die Funktion "signieren()" weitergegeben, die dann die Cipher signiert. 
    <br>
    Das Ergebnis sollte <span style="color: green; font-weight: bold;">true</span> sein. 
  </p>
  <button id="test2">Test 2</button>
  <br>
  <br>
  <br>
  <p>Der dritte Test soll aufzeigen, dass wenn der API Call von einer Variable an eine andere Variable weitergegeben wird, dies auch erkannt wird. Wenn ausgehend vom Encrytion Call, der Ciphertext an unterschiedliche Variablen weitergegeben wird und nur eine in der Sign Methode mündet, wird die Regel als eingehalten erachetet. Wenn aber der API Call von einer Funktion wiedergegeben wird durch "return", dann muss jeder Funktionscall in der Sign Methode münden. In diesen Test gibt es 7 Encrytion Calls. Alle werden in der Funktion "testi3()" über die "return" Methode in einem Array ausgegeben.
    <br>
    <br>
    1. Die erste Cipher wird an die Funktion "t1()" gebunden und mündet in der Funktion in keiner Sign Methode. Sie wird mit dem Index 0 aus der Funktion nirgendwo aufgerufen. 
    <br>
    Das Ergebnis sollte <span style="color: red; font-weight: bold;">false</span> sein.
    <br>
    2. Die zweite Cipher wird an die Variable "t3" gebunden und wird dann an die Variablen "chain1" und "chain2" gebunden. In der Funktion "testi3()" mündet keine der Variablen in der Sign Methode. "t3" wird mit dem Index 1 und chain1 wird mit dem Index 5 aus der Funktion wiedergegeben. Die Funktion "testi3" wird als Argument in der Funktion "chain3()" übergeben. In der Funktion "chain3()" ist eine Funktion "chain4()" definiert, die die Chipher am Index 5 des Arrays aus dem "testi3()" call wiedergibt. "chain4()" wird in der "chain3()" Funktion aufgerufen und dann mit der "then()" Methode wird das Ergebnis signiert. Die Funktion "testi3()" mit dem Index 1 wird nie aufgerufen und mündet entsprechend nie in der Sign Methode. 
    <br>
    Weil aber ein Funktionscall in der Sign Methode müdet, sollte das Ergebnis <span style="color: green; font-weight: bold;">true</span> sein. 
    <br>
    3. Die dritte Cipher ist in einem Objekt mit dem Key "t4" an die Variable "t4" gebunden. Sie wird mit dem Index 2 aus der Funktion "testi3()" wiedergegeben. Die Variable mündet in der Funktion in keiner Sign Methode. Die Funktion "testi3()" wird an die Variable "das" gebunden. "das" wird dann in der Funktion "ee" an die Variable "chain7" gebunden. Über die "then()" Methode wird dann "chain7" aufgerufen und über eine eine Funktion in der "then()" Methode die Cipher am Index 2 und mit dem Key "t4" wiedergegeben. Mit einer weiteren "then()" Methode wird dann das Ergebnis über "console.log" in der Konsole ausgegeben. Damit wird zwar auf die Cipher zugegriffen aber Sie müdet nie in der Sign Methode. 
    <br>
    Das Ergebnis sollte <span style="color: red; font-weight: bold;">false</span> sein. 
    <br>
    4. Die vierte Cipher ist in einem Objekt mit dem Key "t6", das in einem Array enthalten ist am Index 3. Dieses Array ist an die Variable "t5" gebunden. Die Variable mündet in der Funktion "testi3()" in keiner Sign Methode. "testi3()" gibt die Variable mit dem Index 3 wieder. "testi3()" wird an die Variable "das" gebunden. In der Funktion "ee()" wird das Ergebnis aus "das" über die "await" Funktion in der Variable "chain5" gespeichert. Die Cipher wird über "await chain5[3][3].t6" in der Variable "chain6" gespeichert. In der Funktion "ee()" wird dann die Sign Methode aufgerufen, wobei "chain6" als Argument des zu signierenden Textes übergeben wird. 
    <br>
    Das Ergebnis sollte <span style="color: green; font-weight: bold;">true</span> sein. 
    <br>
    5. Die fünfte Cipher ist in einem Objekt mit dem Key "t6", das in einem Array enthalten ist am Index 3. Dieses Array ist an die Variable "t6" gebunden. Die Cipher aus "t6" wird über "let abc = t6[3].t6;" an die Variable "abc" gebunde. Die Cipher wird dann über einen "then()" Signiert und mündet damit in einer Sign Methode. "t6[3]" wird auch an die Variable "ab" weitergegeben. Diese müdent über den call "ab.t6.then()" ebenfalls in einer Sign Methode. Außerdem wird "t6" am Index 4 aus der "testi3()" Funktion wiedergegeben. Diese wird aber nie aufgerufen. 
    <br>
    Da aber in der Funktion "t6" die Cipher in einer Sign Methode mündet, sollte das Ergebnis <span style="color: green; font-weight: bold;">true</span> sein.
    <br>
    6. Die sechste Cipher ist in einer "FunctionExpression" enthalten, die in einem "then()" call enthalten ist, bei dem vorher der Key generiert wird. Die Cipher wird in der "FunctionExpression" in der Variable "cip" gespeichert und dann über "return" an den nächsten "then()" call weitergegeben. In dem "then()" call mündet dann die Cipher in einer Sign Methode. 
    <br>
    Das Ergebins sollte <span style="color: green; font-weight: bold;">true</span> sein.
  </p>
  <button id="test3">Test 3</button>
  <br>
  <br>
  <br>
  <p>
    Test 4
  </p>
  <button id="test4">Test 4</button>
  <br>
  <br>
  <br>
  <p>
    Test 5
  </p>
  <button id="test5">Test 5</button>
  <br>
  <br>
  <br>
  <p>
    Test aller Scripts auf einmal.
  </p>
  <button id="test6">Test 6</button>
  <br>
  <br>
  <br>


  <script>
    let test1 = document.getElementById("test1");
    let test2 = document.getElementById("test2");
    let test3 = document.getElementById("test3");
    let test4 = document.getElementById("test4");
    let test5 = document.getElementById("test5");
    let test6 = document.getElementById("test6");

    function delay(time) {
      return new Promise(resolve => setTimeout(resolve, time));
    }

    test1.addEventListener("click", async function() {
      let script1 = document.createElement("script");
      script1.src = "Variablenbinndung.js";
      try{
        for(let i = 0; i < document.scripts.length; i++) {
          document.head.removeChild(document.scripts[i]);
        }      }
      catch (e) {
        console.log(e);
      }
      await delay(1000);
      document.head.appendChild(script1);
    });

    test2.addEventListener("click", async function() {
      let script2 = document.createElement("script");
      script2.src = "Funktionswiedergabe.js";
      try{
        for(let i = 0; i < document.scripts.length; i++) {
          document.head.removeChild(document.scripts[i]);
        }      }
      catch (e) {
        console.log(e);
      }
      await delay(1000);
      document.head.appendChild(script2);
    });

    test3.addEventListener("click", async function() {
      let script3 = document.createElement("script");
      script3.src = "Chaining.js";
      try{
        for(let i = 0; i < document.scripts.length; i++) {
          document.head.removeChild(document.scripts[i]);
        }      }
      catch (e) {
        console.log(e);
      }
      await delay(1000);
      document.head.appendChild(script3);
    });

    test4.addEventListener("click", async function() {
      let script4 = document.createElement("script");
      script4.src = "Funktionsaufruf.js";
      try{
        for(let i = 0; i < document.scripts.length; i++) {
          document.head.removeChild(document.scripts[i]);
        }      }
      catch (e) {
        console.log(e);
      }
      await delay(1000);
      document.head.appendChild(script4);
    });

    test5.addEventListener("click", async function() {
      let script5 = document.createElement("script");
      script5.src = "Then()Call.js";
      try{
        for(let i = 0; i < document.scripts.length; i++) {
          document.head.removeChild(document.scripts[i]);
        }      }
      catch (e) {
        console.log(e);
      }
      await delay(1000);
      document.head.appendChild(script5);
    });

    test6.addEventListener("click", async function() {
      let script1 = document.createElement("script");
      let script2 = document.createElement("script");
      let script3 = document.createElement("script");
      let script4 = document.createElement("script");
      let script5 = document.createElement("script");
      script1.src = "Variablenbinndung.js";
      script2.src = "Funktionswiedergabe.js";
      script3.src = "Chaining.js";
      script4.src = "Funktionsaufruf.js";
      script5.src = "Then()Call.js";
      try{
        for(let i = 0; i < document.scripts.length; i++) {
          document.head.removeChild(document.scripts[i]);
        }      }
      catch (e) {
        console.log(e);
      }
      await delay(1000);
      document.head.appendChild(script1);
      document.head.appendChild(script2);
      document.head.appendChild(script3);
      document.head.appendChild(script4);
      document.head.appendChild(script5);
    });
    
  </script>
</body>

</html>